#!/usr/bin/env python
import rospy
import sys
import json
import time
import signal

import paho.mqtt.client as mqtt
from tf2_msgs.msg import TFMessage
from std_msgs.msg import Float64
from ur_msgs.srv import SetSpeedSliderFraction, SetIO
from std_srvs.srv import Trigger
import actionlib
from control_msgs.msg import FollowJointTrajectoryAction, FollowJointTrajectoryGoal
from trajectory_msgs.msg import JointTrajectoryPoint
from controller_manager_msgs.srv import SwitchControllerRequest, SwitchController
from controller_manager_msgs.srv import LoadControllerRequest, LoadController
from controller_manager_msgs.srv import ListControllers, ListControllersRequest
import geometry_msgs.msg as geometry_msgs
from cartesian_control_msgs.msg import (
    FollowCartesianTrajectoryAction,
    FollowCartesianTrajectoryGoal,
    CartesianTrajectoryPoint,
)

import json
import pyrebase

import os

api_key = os.getenv("API_KEY")
if api_key is None:
    raise ValueError("No API key found. Please set the API_KEY environment variable.")

# Configure the Firebase app
config = {
    "apiKey": api_key,
    "authDomain": "crafts-extended.firebaseapp.com",
    "databaseURL": "https://crafts-extended-default-rtdb.europe-west1.firebasedatabase.app",
    "storageBucket": "crafts-extended.appspot.com",
}

# If your robot description is created with a tf_prefix, those would have to be adapted
JOINT_NAMES = [
    "shoulder_pan_joint",
    "shoulder_lift_joint",
    "elbow_joint",
    "wrist_1_joint",
    "wrist_2_joint",
    "wrist_3_joint",
]

# All of those controllers can be used to execute joint-based trajectories.
# The scaled versions should be preferred over the non-scaled versions.
JOINT_TRAJECTORY_CONTROLLERS = [
    "scaled_pos_joint_traj_controller",
    "scaled_vel_joint_traj_controller",
    "pos_joint_traj_controller",
    "vel_joint_traj_controller",
    "forward_joint_traj_controller",
]

# All of those controllers can be used to execute Cartesian trajectories.
# The scaled versions should be preferred over the non-scaled versions.
CARTESIAN_TRAJECTORY_CONTROLLERS = [
    "pose_based_cartesian_traj_controller",
    "joint_based_cartesian_traj_controller",
    "forward_cartesian_traj_controller",
]

# We'll have to make sure that none of these controllers are running, as they will
# be conflicting with the joint trajectory controllers
CONFLICTING_CONTROLLERS = ["joint_group_vel_controller", "twist_controller"]

# Configuration
MQTT_SERVER = "test.mosquitto.org"
MODE_TOPIC = "carpenters_robot/mode"
TCP_TOPIC = "carpenters_robot/tcp"
IMAGE_TOPIC = "carpenters_robot/img"
ID_TOPIC = "carpenters_robot/id"
NICLAIOT_TOPIC = "carpenters_robot/iot"
SPEED_TOPIC = "carpenters_robot/speed"
COMMANDS_TOPIC = "carpenters_robot/commands"
TLS_PORT = 8081
NORMAL_PORT = 1883

# Filepaths
DESIGN_FILEPATH = "/home/github/crafts_extended/json/design_frames.json"
ALIGNMENT_FILEPATH = "/home/github/crafts_extended/json/alignment_frames.json"
TOOLPATH = "/home/github/crafts_extended/json/toolpath.json"
FIREBASE_CRED_PATH = "/home/github/crafts_extended/json/crafts-extended-firebase-adminsdk-9by4u-dbb1c0b4e9.json"

# ROS Topics
TOOLFRAME_TOPIC = "/tf"
FREEDRIVE_TOPIC = "/ur_hardware_interface/enable_freedrive_mode"
# Services
SET_SPEED_TOPIC = "/ur_hardware_interface/set_speed_slider"
SET_IO_TOPIC = "/ur_hardware_interface/set_io"
PLAY_TOPIC = "/ur_hardware_interface/dashboard/play"
STOP_TOPIC = "/ur_hardware_interface/dashboard/stop"

# Global Variables
# MODES: 0 - DESIGN; 1 - ALIGN; 2 - NOFREE; 3 - MILLING
freedrive_pub = None
freedrive = False
cur_mode = 0

alignment_pts = []

#################################################################################################
#################################################################################################
#                                                                                               #
#                                 Firebase related functions                                    #
#                                                                                               #
#################################################################################################

# set database paths
alignment = "alignment/"
actual_member = "actual_member/"
design_list = "design_list/"


# Initialize the Firebase app
firebase = pyrebase.initialize_app(config)
db = firebase.database()


# Function to set data in Realtime Database
def set_data_in_realtime_db(reference, data):
    db.child(reference).set(data)


def set_alignment():
    data = {"ID": "", "coordinates": [0, 0, 0]}
    set_data_in_realtime_db(alignment, data)


def update_alignment(mesh_ID="default", pts=[0, 0, 0], marker_ids=["1", "2", "3"]):
    db.child(alignment).child("ID").set(mesh_ID)
    for pt, marker in zip(pts, marker_ids):
        db.child(alignment).child("coordinates").child(marker).set(pt)


#################################################################################################
#                                                                                               #
#                               Trajectory controllers                                          #
#                                                                                               #
#################################################################################################


class TrajectoryClient:
    """Small trajectory client to test a joint trajectory"""

    def __init__(self):
        rospy.init_node("test_move")

        timeout = rospy.Duration(5)
        self.switch_srv = rospy.ServiceProxy(
            "controller_manager/switch_controller", SwitchController
        )
        self.load_srv = rospy.ServiceProxy(
            "controller_manager/load_controller", LoadController
        )
        self.list_srv = rospy.ServiceProxy(
            "controller_manager/list_controllers", ListControllers
        )
        try:
            self.switch_srv.wait_for_service(timeout.to_sec())
        except rospy.exceptions.ROSException as err:
            rospy.logerr(
                "Could not reach controller switch service. Msg: {}".format(err)
            )
            sys.exit(-1)

        self.joint_trajectory_controller = JOINT_TRAJECTORY_CONTROLLERS[0]
        self.cartesian_trajectory_controller = CARTESIAN_TRAJECTORY_CONTROLLERS[0]

    def send_joint_trajectory(self, configs):
        """Creates a trajectory and sends it using the selected action server"""

        # make sure the correct controller is loaded and activated
        self.switch_controller(self.joint_trajectory_controller)
        trajectory_client = actionlib.SimpleActionClient(
            "{}/follow_joint_trajectory".format(self.joint_trajectory_controller),
            FollowJointTrajectoryAction,
        )

        # Wait for action server to be ready
        timeout = rospy.Duration(5)
        if not trajectory_client.wait_for_server(timeout):
            rospy.logerr("Could not reach controller action server.")
            sys.exit(-1)

        # Create and fill trajectory goal
        goal = FollowJointTrajectoryGoal()
        goal.trajectory.joint_names = JOINT_NAMES

        # The following list are arbitrary positions
        # Change to your own needs if desired
        position_list = []
        velocity_list = []
        duration_list = []
        for config in configs:
            position_list.append(config)
            velocity_list.append([0.05] * 6)
            duration_list.append(5.0 * (configs.index(config) + 1))

        for i, position in enumerate(position_list):
            point = JointTrajectoryPoint()
            point.positions = position
            point.velocities = velocity_list[i]
            point.time_from_start = rospy.Duration(duration_list[i])
            goal.trajectory.points.append(point)

        self.ask_confirmation(position_list)
        rospy.loginfo(
            "Executing trajectory using the {}".format(self.joint_trajectory_controller)
        )

        trajectory_client.send_goal(goal)
        trajectory_client.wait_for_result()

        result = trajectory_client.get_result()
        rospy.loginfo(
            "Trajectory execution finished in state {}".format(result.error_code)
        )

    def send_cartesian_trajectory(self, trajectory):
        """Creates a Cartesian trajectory and sends it using the selected action server"""
        self.switch_controller(self.cartesian_trajectory_controller)

        # make sure the correct controller is loaded and activated
        goal = FollowCartesianTrajectoryGoal()

        trajectory_client = actionlib.SimpleActionClient(
            "{}/follow_cartesian_trajectory".format(
                self.cartesian_trajectory_controller
            ),
            FollowCartesianTrajectoryAction,
        )

        # Wait for action server to be ready
        timeout = rospy.Duration(5)
        if not trajectory_client.wait_for_server(timeout):
            rospy.logerr("Could not reach controller action server.")
            sys.exit(-1)

        # The following list are arbitrary positions
        # Change to your own needs if desired
        pose_list = []
        time_list = []

        for point in trajectory:
            pose_list.append(
                geometry_msgs.Pose(
                    geometry_msgs.Vector3(
                        point["point"][0], point["point"][1], point["point"][2]
                    ),
                    geometry_msgs.Quaternion(*point["orientation"]),
                )
            )
            time_list.append(point["timestamp"])

        for pose, time in zip(pose_list, time_list):
            trajectory_point = CartesianTrajectoryPoint()
            trajectory_point.pose = pose
            trajectory_point.twist = geometry_msgs.Twist(
                linear=geometry_msgs.Vector3(0.005, 0.005, 0.005),
                angular=geometry_msgs.Vector3(0.005, 0.005, 0.005),
            )
            trajectory_point.acceleration = geometry_msgs.Accel(
                linear=geometry_msgs.Vector3(0.005, 0.005, 0.005),
                angular=geometry_msgs.Vector3(0.005, 0.005, 0.005),
            )
            trajectory_point.time_from_start = rospy.Duration(time)

            goal.trajectory.points.append(trajectory_point)

        self.ask_confirmation(pose_list)

        rospy.loginfo(
            "Executing trajectory using the {}".format(
                self.cartesian_trajectory_controller
            )
        )
        trajectory_client.send_goal(goal)
        trajectory_client.wait_for_result()

        result = trajectory_client.get_result()

        rospy.loginfo(
            "Trajectory execution finished in state {}".format(result.error_code)
        )

    ###############################################################################################
    #                                                                                             #
    # Methods defined below are for the sake of safety / flexibility of this demo script only.    #
    # If you just want to copy the relevant parts to make your own motion script you don't have   #
    # to use / copy all the functions below.                                                      #
    #                                                                                             #
    ###############################################################################################

    def ask_confirmation(self, waypoint_list):
        """Ask the user for confirmation. This function is obviously not necessary, but makes sense
        in a testing script when you know nothing about the user's setup."""
        rospy.logwarn(
            "The robot will move to the following waypoints: \n{}".format(waypoint_list)
        )
        confirmed = False
        valid = False
        while not valid:
            input_str = input(
                "Please confirm that the robot path is clear of obstacles.\n"
                "Keep the EM-Stop available at all times. You are executing\n"
                "the motion at your own risk. Please type 'y' to proceed or 'n' to abort: "
            )
            valid = input_str in ["y", "n"]
            if not valid:
                rospy.loginfo("Please confirm by entering 'y' or abort by entering 'n'")
            else:
                confirmed = input_str == "y"
        if not confirmed:
            rospy.loginfo("Exiting as requested by user.")
            sys.exit(0)

    def switch_controller(self, target_controller):
        """Activates the desired controller and stops all others from the predefined list above"""
        other_controllers = (
            JOINT_TRAJECTORY_CONTROLLERS
            + CARTESIAN_TRAJECTORY_CONTROLLERS
            + CONFLICTING_CONTROLLERS
        )

        other_controllers.remove(target_controller)

        srv = ListControllersRequest()
        response = self.list_srv(srv)
        for controller in response.controller:
            if controller.name == target_controller and controller.state == "running":
                return

        srv = LoadControllerRequest()
        srv.name = target_controller
        self.load_srv(srv)

        srv = SwitchControllerRequest()
        srv.stop_controllers = other_controllers
        srv.start_controllers = [target_controller]
        srv.strictness = SwitchControllerRequest.BEST_EFFORT
        self.switch_srv(srv)


#################################################################################################
#                                                                                               #
#                     Listeners and Subscribers for state management                            #
#                                                                                               #
#################################################################################################


def listen_tcp(id):
    """
    Listens to the "/tf" topic
    """
    data = rospy.wait_for_message(TOOLFRAME_TOPIC, TFMessage)
    tcp_frame = {
        "id": id,
        "position": [
            data.transforms[0].transform.translation.x,
            data.transforms[0].transform.translation.y,
            data.transforms[0].transform.translation.z,
        ],
    }

    if cur_mode == "0":
        # Save the design TCP frame to with the received id to a JSON file
        pass
    elif cur_mode == "1":
        # Save the alignment TCP frame to a JSON file with assigned id based on count in JSON file
        alignment_pts.append(tcp_frame)

    rospy.loginfo("current length of alignment points: %s", len(alignment_pts))

    if len(alignment_pts) == 3:
        rospy.loginfo("Alignment points received, uploading to firebase")
        rospy.loginfo(alignment_pts)
        update_alignment(
            pts=[pt["position"] for pt in alignment_pts],
            marker_ids=[pt["id"] for pt in alignment_pts],
        )

    rospy.sleep(0.5)  # Wait for 0.5 seconds
    rospy.loginfo(tcp_frame)


def set_speed(speed):
    """
    Sets the speed slider fraction for the UR robot.

    Args:
        speed (float): The desired speed fraction (between 0.0 and 1.0).

    Raises:
        rospy.ServiceException: If the service call to set the speed slider fails.
    """
    try:
        rospy.wait_for_service(SET_SPEED_TOPIC)
        speed_fraction = rospy.ServiceProxy(SET_SPEED_TOPIC, SetSpeedSliderFraction)
        speed_fraction(speed)
    except rospy.ServiceException as e:
        rospy.ERROR(f"Service call failed: {e}")


def play_program():
    """
    Plays the program on the Universal Robots dashboard.

    This function waits for the "/ur_hardware_interface/dashboard/play" service to become available,
    then calls the service to play the program.

    Raises:
        rospy.ServiceException: If the service call fails.
    """
    try:
        rospy.wait_for_service(PLAY_TOPIC)
        play = rospy.ServiceProxy(PLAY_TOPIC, Trigger)
        play()
    except rospy.ServiceException as e:
        rospy.ERROR(f"Service call failed: {e}")


def stop_program():
    """
    Stops the program execution on the Universal Robots robot by calling the "/ur_hardware_interface/dashboard/stop" service.

    This function waits for the service to become available, creates a service proxy, and then calls the service to stop the program execution.
    If an exception occurs during the service call, it logs an error message.

    :return: None
    """
    try:
        rospy.wait_for_service(STOP_TOPIC)
        stop = rospy.ServiceProxy(STOP_TOPIC, Trigger)
        stop()
    except rospy.ServiceException as e:
        rospy.ERROR(f"Service call failed: {e}")


def set_io(id, value=False):
    """
    Sets the value of a specific I/O pin on the Universal Robots robot.

    Args:
        id (int): The ID of the I/O pin to set.
        value (bool, optional): The value to set the I/O pin to. Defaults to False.

    Raises:
        rospy.ServiceException: If the service call to set the I/O pin fails.
    """
    try:
        rospy.wait_for_service(SET_IO_TOPIC)
        setio = rospy.ServiceProxy(SET_IO_TOPIC, SetIO)
        val = 1.0 if value else 0.0
        setio(1, id, val)
    except rospy.ServiceException as e:
        rospy.ERROR(f"Service call failed: {e}")


def freedrive_on():
    """
    Enables the freedrive mode on the robot.

    This function stops the current program, sets the I/O pin 1 to True,
    sleeps for 0.5 seconds, and publishes a message to enable freedrive mode.

    Note: Make sure to have the necessary dependencies imported and initialized
    before calling this function.

    """
    stop_program()
    set_io(1, True)
    rospy.sleep(0.5)
    freedrive_pub.publish(1.0)


def freedrive_off():
    """
    Turn off the freedrive mode.

    This function sets the I/O pin to False to disable the freedrive mode and
    then waits for 0.5 seconds using rospy.sleep().

    """
    set_io(1, False)
    rospy.sleep(0.5)


def on_connect(client, userdata, flags, rc):
    """
    Callback function that is called when the client connects to the MQTT broker.

    Parameters:
        client (mqtt.Client): The MQTT client instance.
        userdata: The user data that was passed to the client when it was created.
        flags: Response flags sent by the broker.
        rc (int): The connection result code.

    Returns:
        None
    """
    rospy.loginfo(f"Connected with result code {rc}")
    client.subscribe(MODE_TOPIC)


def on_message_design_align(client, userdata, message):
    """
    Callback for handling messages in mode 0.
    """
    rospy.loginfo(
        f"Design-Align mode message received: {message.payload.decode('utf-8')}"
    )
    listen_tcp(message.payload.decode("utf-8"))
    # Add specific actions for mode 0


def on_message_fabrication(client, userdata, message):
    """
    Callback for handling messages in mode 3.
    """
    rospy.loginfo(
        f"Fabrication mode message received: {message.payload.decode('utf-8')}"
    )
    # Add specific actions for mode 3
    play_program()
    rospy.sleep(0.5)
    set_speed(1.0)
    rospy.sleep(0.5)
    mover = TrajectoryClient()

    with open(TOOLPATH, "r") as f:
        toolpath = json.load(f)

    config = toolpath[0]

    mover.send_joint_trajectory([config])
    mover.send_cartesian_trajectory(trajectory=toolpath[2:])


def on_message(client, userdata, message):
    """
    Callback function that is called when a message is received.

    Parameters:
    - client: The MQTT client instance that received the message.
    - userdata: Any user-defined data that was passed to the MQTT client.
    - message: The received message object.

    Returns:
    None
    """
    global mode, freedrive, cur_mode
    msg = message.payload.decode("utf-8")
    mode = str(msg)  # Assuming mode is sent as an integer string

    if mode == "0" or mode == "1":
        client.message_callback_add(TCP_TOPIC, on_message_design_align)
        client.subscribe(TCP_TOPIC)
        rospy.loginfo("Switched to alignment and design mode")
        cur_mode = mode
        set_io(0, False)
        rospy.sleep(0.5)
    elif mode == "3":
        client.message_callback_add(COMMANDS_TOPIC, on_message_fabrication)
        client.subscribe(COMMANDS_TOPIC)
        rospy.loginfo("Switched to fabrication mode")
        cur_mode = mode
    else:
        pass  # retain current mode

    if mode == "0" or mode == "1":
        rospy.loginfo("Freedrving")
        if not freedrive:
            freedrive = True
            freedrive_on()
    elif mode == "2":
        if freedrive:
            freedrive = False
            freedrive_off()
    else:
        pass

    rospy.loginfo("Current mode: %s", cur_mode)


def on_disconnect(client, userdata, rc):
    """
    Callback function called when the MQTT client is disconnected from the broker.

    Parameters:
        client: The MQTT client instance.
        userdata: The user data associated with the client.
        rc: The disconnection result code.

    Returns:
        None
    """
    rospy.loginfo("Disconnected from MQTT broker.")


def handle_shutdown(signum, frame):
    """
    Handles the shutdown of the program.

    Args:
        signum (int): The signal number.
        frame (frame): The current stack frame.

    Returns:
        None
    """
    rospy.loginfo("Exiting...")
    client.loop_stop()
    client.disconnect()
    rospy.signal_shutdown("KeyboardInterrupt")


if __name__ == "__main__":
    signal.signal(signal.SIGINT, handle_shutdown)
    signal.signal(signal.SIGTERM, handle_shutdown)

    client = mqtt.Client()
    client.on_connect = on_connect
    client.on_message = on_message
    client.on_disconnect = on_disconnect

    try:
        client.connect(MQTT_SERVER, NORMAL_PORT, 60)
        time.sleep(0.1)
        client.loop_start()
    except Exception as e:
        rospy.ERROR(f"Failed to connect to MQTT broker: {e}")
        exit(1)

    rospy.init_node("worker", anonymous=True)

    freedrive_pub = rospy.Publisher(FREEDRIVE_TOPIC, Float64, queue_size=10)

    rospy.spin()
    # listener()
