#!/usr/bin/env python
import rospy
import json
import time
import signal
import logging
import paho.mqtt.client as mqtt
from tf2_msgs.msg import TFMessage
from std_msgs.msg import Float64
from ur_msgs.srv import SetSpeedSliderFraction, SetIO
from std_srvs.srv import Trigger

# Configuration
MQTT_SERVER = "test.mosquitto.org"
FREE_TOPIC = "carpenters_robot/free"
TCP_TOPIC = "carpenters_robot/tcp" 
IMAGE_TOPIC = "carpenters_robot/img"
ID_TOPIC = "carpenters_robot/id"
NICLAIOT_TOPIC = "carpenters_robot/iot"
CONFIRM_TOPIC = "carpenters_robot/confirm"
SPEED_TOPIC = "carpenters_robot/speed"
COMMANDS_TOPIC = "carpenters_robot/commands"
TLS_PORT = 8081
NORMAL_PORT = 1883
FILEPATH = "/home/github/crafts_extended/json/tcp_frames.json"

# ROS Topics
TOOLFRAME_TOPIC = "/tf"
FREEDRIVE_TOPIC = "/ur_hardware_interface/enable_freedrive_mode"
# Services
SET_SPEED_TOPIC = "/ur_hardware_interface/set_speed_slider"
SET_IO_TOPIC = "/ur_hardware_interface/set_io"
PLAY_TOPIC = "/ur_hardware_interface/dashboard/play"
STOP_TOPIC = "/ur_hardware_interface/dashboard/stop"

# Global Variables
# MODES: 0 - DESIGN; 1 - ALIGN; 2 - NOFREE; 3 - MILLING
freedrive_pub = None
freedrive = False
mode = 0

# Setup logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)


def listen_tcp(id):
    """
    Listens to the "/tf" topic
    """
    data = rospy.wait_for_message(TOOLFRAME_TOPIC, TFMessage)
    tcp_frame = {
            "id": id,
            "position": data.transforms[0].transform.translation,
        }
    rospy.loginfo(tcp_frame)




def set_speed(speed):
    """
    Sets the speed slider fraction for the UR robot.

    Args:
        speed (float): The desired speed fraction (between 0.0 and 1.0).

    Raises:
        rospy.ServiceException: If the service call to set the speed slider fails.
    """
    try:
        rospy.wait_for_service(SET_SPEED_TOPIC)
        speed_fraction = rospy.ServiceProxy(
            SET_SPEED_TOPIC, SetSpeedSliderFraction
        )
        speed_fraction(speed)
    except rospy.ServiceException as e:
        logging.error(f"Service call failed: {e}")


def play_program():
    """
    Plays the program on the Universal Robots dashboard.

    This function waits for the "/ur_hardware_interface/dashboard/play" service to become available,
    then calls the service to play the program.

    Raises:
        rospy.ServiceException: If the service call fails.
    """
    try:
        rospy.wait_for_service(PLAY_TOPIC)
        play = rospy.ServiceProxy(PLAY_TOPIC, Trigger)
        play()
    except rospy.ServiceException as e:
        logging.error(f"Service call failed: {e}")


def stop_program():
    """
    Stops the program execution on the Universal Robots robot by calling the "/ur_hardware_interface/dashboard/stop" service.

    This function waits for the service to become available, creates a service proxy, and then calls the service to stop the program execution.
    If an exception occurs during the service call, it logs an error message.

    :return: None
    """
    try:
        rospy.wait_for_service(STOP_TOPIC)
        stop = rospy.ServiceProxy(STOP_TOPIC, Trigger)
        stop()
    except rospy.ServiceException as e:
        logging.error(f"Service call failed: {e}")


def set_io(id, value=False):
    """
    Sets the value of a specific I/O pin on the Universal Robots robot.

    Args:
        id (int): The ID of the I/O pin to set.
        value (bool, optional): The value to set the I/O pin to. Defaults to False.

    Raises:
        rospy.ServiceException: If the service call to set the I/O pin fails.
    """
    try:
        rospy.wait_for_service(SET_IO_TOPIC)
        setio = rospy.ServiceProxy(SET_IO_TOPIC, SetIO)
        val = 1.0 if value else 0.0
        setio(1, id, val)
    except rospy.ServiceException as e:
        logging.error(f"Service call failed: {e}")


def freedrive_on():
    """
    Enables the freedrive mode on the robot.

    This function stops the current program, sets the I/O pin 1 to True,
    sleeps for 0.5 seconds, and publishes a message to enable freedrive mode.

    Note: Make sure to have the necessary dependencies imported and initialized
    before calling this function.

    """
    stop_program()
    set_io(1, True)
    rospy.sleep(0.5)
    freedrive_pub.publish(1.0)


def freedrive_off():
    """
    Turn off the freedrive mode.

    This function sets the I/O pin to False to disable the freedrive mode and
    then waits for 0.5 seconds using rospy.sleep().

    """
    set_io(1, False)
    rospy.sleep(0.5)


def on_connect(client, userdata, flags, rc):
    """
    Callback function that is called when the client connects to the MQTT broker.

    Parameters:
        client (mqtt.Client): The MQTT client instance.
        userdata: The user data that was passed to the client when it was created.
        flags: Response flags sent by the broker.
        rc (int): The connection result code.

    Returns:
        None
    """
    rospy.loginfo(f"Connected with result code {rc}")
    client.subscribe(FREE_TOPIC)


def on_message_design_align(client, userdata, message):
    """
    Callback for handling messages in mode 0.
    """
    rospy.loginfo(f"Design-Align mode message received: {message.payload.decode('utf-8')}")
    listen_tcp(message.payload.decode('utf-8'))
    # Add specific actions for mode 0

def on_message_fabrication(client, userdata, message):
    """
    Callback for handling messages in mode 3.
    """
    rospy.loginfo(f"Fabbrication mode message received: {message.payload.decode('utf-8')}")
    # Add specific actions for mode 1

def on_message(client, userdata, message):
    """
    Callback function that is called when a message is received.

    Parameters:
    - client: The MQTT client instance that received the message.
    - userdata: Any user-defined data that was passed to the MQTT client.
    - message: The received message object.

    Returns:
    None
    """
    global mode, freedrive
    msg = message.payload.decode("utf-8")
    rospy.loginfo(f"Received message: {msg}")
    mode = str(msg)  # Assuming mode is sent as an integer string
    
    mode = '0' if msg == '"NO_FREEDRIVE"' else '2'

    if mode == '0' or mode == '1':
        rospy.loginfo_once("switched mode")
        client.message_callback_add(TCP_TOPIC, on_message_design_align)
        client.subscribe(TCP_TOPIC)
        rospy.loginfo("Switched to alignment and design mode")

    elif mode == '3':
        client.message_callback_add(COMMANDS_TOPIC, on_message_fabrication)
        client.subscribe(COMMANDS_TOPIC)
        rospy.loginfo("Switched to fabrication mode")

    if msg == '0' or msg == '1':
        if not freedrive:
            freedrive = True
            freedrive_on()
    elif msg == '2':
        if freedrive:
            freedrive = False
            freedrive_off()
    else:
        pass


def on_disconnect(client, userdata, rc):
    """
    Callback function called when the MQTT client is disconnected from the broker.

    Parameters:
        client: The MQTT client instance.
        userdata: The user data associated with the client.
        rc: The disconnection result code.

    Returns:
        None
    """
    rospy.loginfo("Disconnected from MQTT broker.")


def handle_shutdown(signum, frame):
    """
    Handles the shutdown of the program.

    Args:
        signum (int): The signal number.
        frame (frame): The current stack frame.

    Returns:
        None
    """
    rospy.loginfo("Exiting...")
    client.loop_stop()
    client.disconnect()
    rospy.signal_shutdown("KeyboardInterrupt")


if __name__ == "__main__":
    signal.signal(signal.SIGINT, handle_shutdown)
    signal.signal(signal.SIGTERM, handle_shutdown)

    client = mqtt.Client()
    client.on_connect = on_connect
    client.on_message = on_message
    client.on_disconnect = on_disconnect

    try:
        client.connect(MQTT_SERVER, NORMAL_PORT, 60)
        time.sleep(0.1)
        client.loop_start()
    except Exception as e:
        logging.error(f"Failed to connect to MQTT broker: {e}")
        exit(1)

    rospy.init_node("worker", anonymous=True)
    
    freedrive_pub = rospy.Publisher(
        FREEDRIVE_TOPIC, Float64, queue_size=10
    )


    rospy.spin()
    # listener()
